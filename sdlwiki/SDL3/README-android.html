<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README-android</title>
  <style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>
  <style type="text/css">:root {
color-scheme: dark light; 
}
body {
background-color: white;
padding: 2vw;
color: #333;
max-width: 1200px;
margin: 0 auto;
font-size: 16px;
line-height: 1.5;
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans",
Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
overflow-wrap: break-word;
}
a {
color: #0969da;

}
a:visited {
color: #064998;
}
h1 {
border-bottom: 2px solid #efefef;
}
h2 {
border-bottom: 1px solid #efefef;
}
p {
max-width: 85ch;
}
li {
max-width: 85ch;
}
div.sourceCode {
background-color: #f6f8fa;
max-width: 100%;
padding: 16px;
}
code {
background-color: #f6f8fa;
padding: 0px;
font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas,
"Liberation Mono", monospace;
}
table {
border: 1px solid #808080;
border-collapse: collapse;
}
td {
border: 1px solid #808080;
padding: 5px;
}
tr:nth-child(even) {
background-color: #f6f8fa;
}
.wikitopbanner {
display: flex;
justify-content: space-between;
align-items: center;
background-color: #efefef;
padding: 10px;
margin-bottom: 10px;
width: auto;
}
.wikibottombanner {
background-color: #efefef;
padding: 10px;
margin-top: 10px;
width: auto;
}
.alertBox {
background-color: #f8d7da;
border: 1px solid #f5c6cb;
max-width: 60%;
padding: 10;
margin: auto;
}
.anchorImage {
visibility: hidden;
padding-left: 0.2em;
color: #fff;
}
.anchorText:hover .anchorImage {
visibility: visible;
}
hr {
display: block;
height: 1px;
border: 0;
border-top: 1px solid #efefef;
margin: 1em 0;
padding: 0;
}

@media (prefers-color-scheme: dark) {
body {
color: #e6edf3;
background-color: #0d1117;
}
h1 {
border-color: rgba(48, 54, 61, 0.7);
}
h2 {
border-color: rgba(48, 54, 61, 0.7);
}
hr {
border-color: rgba(48, 54, 61, 0.7);
}
div.sourceCode {
background-color: #161b22;
}
code {
background-color: #161b22;
}
a {
color: #4493f8;
}
a:visited {
color: #2f66ad;
}
table {
border-color: rgba(48, 54, 61, 0.7);
}
td {
border-color: rgba(48, 54, 61, 0.7);
}
tr:nth-child(even) {
background-color: #161b22;
}
.wikitopbanner {
background-color: #263040;
}
.wikibottombanner {
background-color: #263040;
}
.anchorText:hover .anchorImage {
filter: invert(100%);
}
}
@media print {
body {
font-size: 12px;
}
table {
font-size: inherit;
}
a:visited {
color: #0969da;
}
.wikitopbanner,
.anchorText,
.wikibottombanner {
display: none;
}
}
</style>
  <style type="text/css"> code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
{ position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
{ content: attr(title);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; pointer-events: all; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
@media (prefers-color-scheme: dark) {
code span.al { color: #95da4c; font-weight: bold; } 
code span.an { color: #3f8058; } 
code span.at { color: #2980b9; } 
code span.bn { color: #f67400; } 
code span.bu { color: #7f8c8d; } 
code span.ch { color: #3daee9; } 
code span.co { color: #7a7c7d; } 
code span.cv { color: #7f8c8d; } 
code span.cn { color: #27aeae; font-weight: bold; } 
code span.cf { color: #fdbc4b; font-weight: bold; } 
code span.dt { color: #2980b9; } 
code span.dv { color: #f67400; } 
code span.do { color: #a43340; } 
code span.er { color: #da4453; } 
code span.ex { color: #0099ff; font-weight: bold; } 
code span.fl { color: #f67400; } 
code span.fu { color: #8e44ad; } 
code span.im { color: #27ae60; } 
code span.in { color: #c45b00; } 
code span.kw { color: #cfcfc2; font-weight: bold; } 
code span.op { color: #cfcfc2; } 
code span.ot { color: #27ae60; } 
code span.pp { color: #27ae60; } 
code span.sc { color: #3daee9; } 
code span.ss { color: #da4453; } 
code span.st { color: #f44f4f; } 
code span.va { color: #27aeae; } 
code span.vs { color: #da4453; } 
code span.wa { color: #da4453; } 
}</style>
</head>
<body>
<h1 id="android">Android</h1>
<p>Matt Styles wrote a tutorial on building SDL for Android with Visual
Studio: <a href="http://trederia.blogspot.de/2017/03/building-sdl2-for-android-with-visual.html">http://trederia.blogspot.de/2017/03/building-sdl2-for-android-with-visual.html</a></p>
<p>The rest of this README covers the Android gradle style build
process.</p>
<h1 id="requirements">Requirements</h1>
<p>Android SDK (version 35 or later) <a href="https://developer.android.com/sdk/index.html">https://developer.android.com/sdk/index.html</a></p>
<p>Android NDK r15c or later <a href="https://developer.android.com/tools/sdk/ndk/index.html">https://developer.android.com/tools/sdk/ndk/index.html</a></p>
<p>Minimum API level supported by SDL: 21 (Android 5.0)</p>
<h1 id="how-the-port-works">How the port works</h1>
<ul>
<li>Android applications are Java-based, optionally with parts written
in C</li>
<li>As SDL apps are C-based, we use a small Java shim that uses JNI to
talk to the SDL library</li>
<li>This means that your application C code must be placed inside an
Android Java project, along with some C support code that communicates
with Java</li>
<li>This eventually produces a standard Android .apk package</li>
</ul>
<p>The Android Java code implements an &quot;Activity&quot; and can be found in:
android-project/app/src/main/java/org/libsdl/app/SDLActivity.java</p>
<p>The Java code loads your game code, the SDL shared library, and
dispatches to native functions implemented in the SDL library:
src/core/android/SDL_android.c</p>
<h1 id="building-a-simple-app">Building a simple app</h1>
<p>For simple projects you can use the script located at
build-scripts/create-android-project.py</p>
<p>There&#39;s two ways of using it:</p>
<pre><code>./create-android-project.py com.yourcompany.yourapp &lt; sources.list
./create-android-project.py com.yourcompany.yourapp source1.c source2.c ...sourceN.c</code></pre>
<p>sources.list should be a text file with a source file name in each
line Filenames should be specified relative to the current directory,
for example if you are in the build-scripts directory and want to create
the testgles.c test, you&#39;ll run:</p>
<pre><code>./create-android-project.py org.libsdl.testgles ../test/testgles.c</code></pre>
<p>One limitation of this script is that all sources provided will be
aggregated into a single directory, thus all your source files should
have a unique name.</p>
<p>Once the project is complete the script will tell you how to build
the project. If you want to create a signed release APK, you can use the
project created by this utility to generate it.</p>
<p>Running the script with <code>--help</code> will list all available
options, and their purposes.</p>
<p>Finally, a word of caution: re running create-android-project.py
wipes any changes you may have done in the build directory for the
app!</p>
<h1 id="building-a-more-complex-app">Building a more complex app</h1>
<p>For more complex projects, follow these instructions:</p>
<ol type="1">
<li><p>Get the source code for SDL and copy the &#39;android-project&#39;
directory located at SDL/android-project to a suitable location in your
project.</p>
<p>The &#39;android-project&#39; directory can basically be seen as a sort of
starting point for the android-port of your project. It contains the
glue code between the Android Java &#39;frontend&#39; and the SDL code
&#39;backend&#39;. It also contains some standard behaviour, like how events
should be handled, which you will be able to change.</p></li>
<li><p>If you are <em>not</em> already building SDL as a part of your
project (e.g. via CMake add_subdirectory() or FetchContent) move or <a href="https://en.wikipedia.org/wiki/Symbolic_link">symlink</a> the SDL
directory into the &#39;android-project/app/jni&#39; directory. Alternatively
you can <a href="#using-the-sdl3-android-archive-aar">use the SDL3
Android Archive (.aar)</a>, see bellow for more details.</p>
<p>This is needed as SDL has to be compiled by the Android
compiler.</p></li>
<li><p>Edit &#39;android-project/app/build.gradle&#39; to include any assets
that your app needs by adding &#39;assets.srcDirs&#39; in &#39;sourceSets.main&#39;.</p>
<p>For example:
<code>assets.srcDirs = [&#39;../../assets&#39;, &#39;../../shaders&#39;]</code></p></li>
</ol>
<p>If using CMake:</p>
<ol start="4" type="1">
<li><p>Edit &#39;android-project/app/build.gradle&#39; to set &#39;buildWithCMake&#39;
to true and set &#39;externalNativeBuild&#39; cmake path to your top level
CMakeLists.txt.</p>
<p>For example: <code>path &#39;../../CMakeLists.txt&#39;</code></p></li>
<li><p>Change the target containing your main function to be built as a
shared library called &quot;main&quot; when compiling for Android. (e.g.
add_executable(MyGame main.c) should become add_library(main SHARED
main.c) on Android)</p></li>
</ol>
<p>If using Android Makefiles:</p>
<ol start="4" type="1">
<li>Edit &#39;android-project/app/jni/src/Android.mk&#39; to include your source
files. They should be separated by spaces after the &#39;LOCAL_SRC_FILES :=
&#39; declaration.</li>
</ol>
<p>To build your app, run <code>./gradlew installDebug</code> or
<code>./gradlew installRelease</code> in the project directory. It will
build and install your .apk on any connected Android device. If you want
to use Android Studio, simply open your &#39;android-project&#39; directory and
start building.</p>
<p>Additionally the <a href="https://github.com/libsdl-org/SDL_helloworld">SDL_helloworld</a>
project contains a small example program with a functional Android port
that you can use as a reference.</p>
<p>Here&#39;s an explanation of the files in the Android project, so you can
customize them:</p>
<pre><code>android-project/app
    build.gradle            - build info including the application version and SDK
    src/main/AndroidManifest.xml    - package manifest. Among others, it contains the class name of the main Activity and the package name of the application.
    jni/            - directory holding native code
    jni/Application.mk  - Application JNI settings, including target platform and STL library
    jni/Android.mk      - Android makefile that can call recursively the Android.mk files in all subdirectories
    jni/CMakeLists.txt  - Top-level CMake project that adds SDL as a subproject
    jni/SDL/        - (symlink to) directory holding the SDL library files
    jni/SDL/Android.mk  - Android makefile for creating the SDL shared library
    jni/src/        - directory holding your C/C++ source
    jni/src/Android.mk  - Android makefile that you should customize to include your source code and any library references
    jni/src/CMakeLists.txt  - CMake file that you may customize to include your source code and any library references
    src/main/assets/    - directory holding asset files for your application
    src/main/res/       - directory holding resources for your application
    src/main/res/mipmap-*   - directories holding icons for different phone hardware
    src/main/res/values/strings.xml - strings used in your application, including the application name
    src/main/java/org/libsdl/app/SDLActivity.java - the Java class handling the initialization and binding to SDL. Be very careful changing this, as the SDL library relies on this implementation. You should instead subclass this for your application.</code></pre>
<h1 id="using-the-sdl3-android-archive-aar">Using the SDL3 Android
Archive (.aar)</h1>
<p>The Android archive allows use of SDL3 in your Android project,
without needing to copy any SDL C or JAVA source into your project. For
integration with CMake/ndk-build, it uses <a href="https://google.github.io/prefab/">prefab</a>.</p>
<p>Copy the archive to a <code>app/libs</code> directory in your project
and add the following to <code>app/gradle.build</code>:</p>
<pre><code>android {
    /* ... */
    buildFeatures {
        prefab true
    }
}
dependencies {
    implementation files(&#39;libs/SDL3-X.Y.Z.aar&#39;) /* Replace with the filename of the actual SDL3-x.y.z.aar file you downloaded */
    /* ... */
}</code></pre>
<p>If you use CMake, add the following to your CMakeLists.txt:</p>
<pre><code>find_package(SDL3 REQUIRED CONFIG)
target_link_libraries(yourgame PRIVATE SDL3::SDL3)</code></pre>
<p>If you use ndk-build, add the following before
<code>include $(BUILD_SHARED_LIBRARY)</code> to your
<code>Android.mk</code>:</p>
<pre><code>LOCAL_SHARED_LIBRARIES := SDL3 SDL3-Headers</code></pre>
<p>And add the following at the bottom:</p>
<pre><code># https://google.github.io/prefab/build-systems.html
# Add the prefab modules to the import path.
$(call import-add-path,/out)
# Import @PROJECT_NAME@ so we can depend on it.
$(call import-module,prefab/@PROJECT_NAME@)</code></pre>
<p>The <code>build-scripts/create-android-project.py</code> script can
create a project using Android aar-chives from scratch:</p>
<pre><code>build-scripts/create-android-project.py --variant aar com.yourcompany.yourapp &lt; sources.list</code></pre>
<h1 id="customizing-your-application-name">Customizing your application
name</h1>
<p>To customize your application name, edit AndroidManifest.xml and
build.gradle to replace &quot;org.libsdl.app&quot; with an identifier for your
product package.</p>
<p>Then create a Java class extending SDLActivity and place it in a
directory under src matching your package, e.g.</p>
<pre><code>app/src/main/java/com/gamemaker/game/MyGame.java</code></pre>
<p>Here&#39;s an example of a minimal class file:</p>
<pre><code>--- MyGame.java --------------------------
package com.gamemaker.game;

import org.libsdl.app.SDLActivity;

/**
 * A sample wrapper class that just calls SDLActivity
 */

public class MyGame extends SDLActivity { }

------------------------------------------</code></pre>
<p>Then replace &quot;SDLActivity&quot; in AndroidManifest.xml with the name of
your class, .e.g. &quot;MyGame&quot;</p>
<h1 id="customizing-your-application-icon">Customizing your application
icon</h1>
<p>Conceptually changing your icon is just replacing the
&quot;ic_launcher.png&quot; files in the drawable directories under the res
directory. There are several directories for different screen sizes.</p>
<h1 id="loading-assets">Loading assets</h1>
<p>Any files you put in the &quot;app/src/main/assets&quot; directory of your
project directory will get bundled into the application package and you
can load them using the standard functions in SDL_iostream.h.</p>
<p>There are also a few Android specific functions that allow you to get
other useful paths for saving and loading data:</p>
<ul>
<li>SDL_GetAndroidInternalStoragePath()</li>
<li>SDL_GetAndroidExternalStorageState()</li>
<li>SDL_GetAndroidExternalStoragePath()</li>
<li>SDL_GetAndroidCachePath()</li>
</ul>
<p>See SDL_system.h for more details on these functions.</p>
<p>The asset packaging system will, by default, compress certain file
extensions. SDL includes two asset file access mechanisms, the preferred
one is the so called &quot;File Descriptor&quot; method, which is faster and
doesn&#39;t involve the Dalvik GC, but given this method does not work on
compressed assets, there is also the &quot;Input Stream&quot; method, which is
automatically used as a fall back by SDL. You may want to keep this fact
in mind when building your APK, specially when large files are involved.
For more information on which extensions get compressed by default and
how to disable this behaviour, see for example:</p>
<p><a href="http://ponystyle.com/blog/2010/03/26/dealing-with-asset-compression-in-android-apps/">http://ponystyle.com/blog/2010/03/26/dealing-with-asset-compression-in-android-apps/</a></p>
<h1 id="activity-lifecycle">Activity lifecycle</h1>
<p>On Android the application goes through a fixed life cycle and you
will get notifications of state changes via application events. When
these events are delivered you must handle them in an event callback
because the OS may not give you any processing time after the events are
delivered.</p>
<p>e.g.</p>
<pre><code>bool HandleAppEvents(void *userdata, SDL_Event *event)
{
    switch (event-&gt;type)
    {
    case SDL_EVENT_TERMINATING:
        /* Terminate the app.
           Shut everything down before returning from this function.
        */
        return false;
    case SDL_EVENT_LOW_MEMORY:
        /* You will get this when your app is paused and iOS wants more memory.
           Release as much memory as possible.
        */
        return false;
    case SDL_EVENT_WILL_ENTER_BACKGROUND:
        /* Prepare your app to go into the background.  Stop loops, etc.
           This gets called when the user hits the home button, or gets a call.

           You should not make any OpenGL graphics calls or use the rendering API,
           in addition, you should set the render target to NULL, if you&#39;re using
           it, e.g. call SDL_SetRenderTarget(renderer, NULL).
        */
        return false;
    case SDL_EVENT_DID_ENTER_BACKGROUND:
        /* Your app is NOT active at this point. */
        return false;
    case SDL_EVENT_WILL_ENTER_FOREGROUND:
        /* This call happens when your app is coming back to the foreground.
           Restore all your state here.
        */
        return false;
    case SDL_EVENT_DID_ENTER_FOREGROUND:
        /* Restart your loops here.
           Your app is interactive and getting CPU again.

           You have access to the OpenGL context or rendering API at this point.
           However, there&#39;s a chance (on older hardware, or on systems under heavy load),
           where the graphics context can not be restored. You should listen for the
           event SDL_EVENT_RENDER_DEVICE_RESET and recreate your OpenGL context and
           restore your textures when you get it, or quit the app.
        */
        return false;
    default:
        /* No special processing, add it to the event queue */
        return true;
    }
}

int main(int argc, char *argv[])
{
    SDL_SetEventFilter(HandleAppEvents, NULL);

    ... run your main loop

    return 0;
}</code></pre>
<p>Note that if you are using main callbacks instead of a standard C
main() function, your SDL_AppEvent() callback will run as these events
arrive and you do not need to use SDL_SetEventFilter.</p>
<p>If SDL_HINT_ANDROID_BLOCK_ON_PAUSE hint is set (the default), the
event loop will block itself when the app is paused (ie, when the user
returns to the main Android dashboard). Blocking is better in terms of
battery use, and it allows your app to spring back to life
instantaneously after resume (versus polling for a resume message).</p>
<p>You can control activity re-creation (eg. onCreate()) behaviour. This
allows you to choose whether to keep or re-initialize java and native
static datas, see SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY in
SDL_hints.h.</p>
<h1 id="insets-and-safe-areas">Insets and Safe Areas</h1>
<p>As of Android 15, SDL windows cover the entire screen, extending
under notches and system bars. The OS expects you to take those into
account when displaying content and SDL provides the function
SDL_GetWindowSafeArea() so you know what area is available for
interaction. Outside of the safe area can be potentially covered by
system bars or used by OS gestures.</p>
<h1 id="mouse--touch-events">Mouse / Touch events</h1>
<p>In some case, SDL generates synthetic mouse (resp. touch) events for
touch (resp. mouse) devices. To enable/disable this behavior, see
SDL_hints.h:</p>
<ul>
<li>SDL_HINT_TOUCH_MOUSE_EVENTS</li>
<li>SDL_HINT_MOUSE_TOUCH_EVENTS</li>
</ul>
<h1 id="misc">Misc</h1>
<p>For some device, it appears to works better setting explicitly GL
attributes before creating a window:
SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 5);
SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 6);
SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 5);</p>
<h1 id="threads-and-the-java-vm">Threads and the Java VM</h1>
<p>For a quick tour on how Linux native threads interoperate with the
Java VM, take a look here: <a href="https://developer.android.com/guide/practices/jni.html">https://developer.android.com/guide/practices/jni.html</a></p>
<p>If you want to use threads in your SDL app, it&#39;s strongly recommended
that you do so by creating them using SDL functions. This way, the
required attach/detach handling is managed by SDL automagically. If you
have threads created by other means and they make calls to SDL
functions, make sure that you call Android_JNI_SetupThread() before
doing anything else otherwise SDL will attach your thread automatically
anyway (when you make an SDL call), but it&#39;ll never detach it.</p>
<p>If you ever want to use JNI in a native thread (created by
&quot;SDL_CreateThread()&quot;), it won&#39;t be able to find your java class and
method because of the java class loader which is different for native
threads, than for java threads (eg your &quot;main()&quot;).</p>
<p>the work-around is to find class/method, in you &quot;main()&quot; thread, and
to use them in your native thread.</p>
<p>see: <a href="https://developer.android.com/training/articles/perf-jni#faq:-why-didnt-findclass-find-my-class">https://developer.android.com/training/articles/perf-jni#faq:-why-didnt-findclass-find-my-class</a></p>
<h1 id="using-stl">Using STL</h1>
<p>You can use STL in your project by creating an Application.mk file in
the jni folder and adding the following line:</p>
<pre><code>APP_STL := c++_shared</code></pre>
<p>For more information go here: <a href="https://developer.android.com/ndk/guides/cpp-support">https://developer.android.com/ndk/guides/cpp-support</a></p>
<h1 id="using-the-emulator">Using the emulator</h1>
<p>There are some good tips and tricks for getting the most out of the
emulator here: <a href="https://developer.android.com/tools/devices/emulator.html">https://developer.android.com/tools/devices/emulator.html</a></p>
<p>Especially useful is the info on setting up OpenGL ES 2.0
emulation.</p>
<p>Notice that this software emulator is incredibly slow and needs a lot
of disk space. Using a real device works better.</p>
<h1 id="troubleshooting">Troubleshooting</h1>
<p>You can see if adb can see any devices with the following
command:</p>
<pre><code>adb devices</code></pre>
<p>You can see the output of log messages on the default device
with:</p>
<pre><code>adb logcat</code></pre>
<p>You can push files to the device with:</p>
<pre><code>adb push local_file remote_path_and_file</code></pre>
<p>You can push files to the SD Card at /sdcard, for example:</p>
<pre><code>adb push moose.dat /sdcard/moose.dat</code></pre>
<p>You can see the files on the SD card with a shell command:</p>
<pre><code>adb shell ls /sdcard/</code></pre>
<p>You can start a command shell on the default device with:</p>
<pre><code>adb shell</code></pre>
<p>You can remove the library files of your project (and not the SDL lib
files) with:</p>
<pre><code>ndk-build clean</code></pre>
<p>You can do a build with the following command:</p>
<pre><code>ndk-build</code></pre>
<p>You can see the complete command line that ndk-build is using by
passing V=1 on the command line:</p>
<pre><code>ndk-build V=1</code></pre>
<p>If your application crashes in native code, you can use ndk-stack to
get a symbolic stack trace: <a href="https://developer.android.com/ndk/guides/ndk-stack">https://developer.android.com/ndk/guides/ndk-stack</a></p>
<p>If you want to go through the process manually, you can use addr2line
to convert the addresses in the stack trace to lines in your code.</p>
<p>For example, if your crash looks like this:</p>
<pre><code>I/DEBUG   (   31): signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 400085d0
I/DEBUG   (   31):  r0 00000000  r1 00001000  r2 00000003  r3 400085d4
I/DEBUG   (   31):  r4 400085d0  r5 40008000  r6 afd41504  r7 436c6a7c
I/DEBUG   (   31):  r8 436c6b30  r9 435c6fb0  10 435c6f9c  fp 4168d82c
I/DEBUG   (   31):  ip 8346aff0  sp 436c6a60  lr afd1c8ff  pc afd1c902  cpsr 60000030
I/DEBUG   (   31):          #00  pc 0001c902  /system/lib/libc.so
I/DEBUG   (   31):          #01  pc 0001ccf6  /system/lib/libc.so
I/DEBUG   (   31):          #02  pc 000014bc  /data/data/org.libsdl.app/lib/libmain.so
I/DEBUG   (   31):          #03  pc 00001506  /data/data/org.libsdl.app/lib/libmain.so</code></pre>
<p>You can see that there&#39;s a crash in the C library being called from
the main code. I run addr2line with the debug version of my code:</p>
<pre><code>arm-eabi-addr2line -C -f -e obj/local/armeabi/libmain.so</code></pre>
<p>and then paste in the number after &quot;pc&quot; in the call stack, from the
line that I care about: 000014bc</p>
<p>I get output from addr2line showing that it&#39;s in the quit function,
in testspriteminimal.c, on line 23.</p>
<p>You can add logging to your code to help show what&#39;s happening:</p>
<pre><code>#include &lt;android/log.h&gt;

__android_log_print(ANDROID_LOG_INFO, &quot;foo&quot;, &quot;Something happened! x = %d&quot;, x);</code></pre>
<p>If you need to build without optimization turned on, you can create a
file called &quot;Application.mk&quot; in the jni directory, with the following
line in it:</p>
<pre><code>APP_OPTIM := debug</code></pre>
<h1 id="memory-debugging">Memory debugging</h1>
<p>The best (and slowest) way to debug memory issues on Android is
valgrind. Valgrind has support for Android out of the box, just grab
code using:</p>
<pre><code>git clone https://sourceware.org/git/valgrind.git</code></pre>
<p>... and follow the instructions in the file
<code>README.android</code> to build it.</p>
<p>One thing I needed to do on macOS was change the path to the
toolchain, and add ranlib to the environment variables: export
RANLIB=$NDKROOT/toolchains/arm-linux-androideabi-4.4.3/prebuilt/darwin-x86/bin/arm-linux-androideabi-ranlib</p>
<p>Once valgrind is built, you can create a wrapper script to launch
your application with it, changing org.libsdl.app to your package
identifier:</p>
<pre><code>--- start_valgrind_app -------------------
#!/system/bin/sh
export TMPDIR=/data/data/org.libsdl.app
exec /data/local/Inst/bin/valgrind --log-file=/sdcard/valgrind.log --error-limit=no $*
------------------------------------------</code></pre>
<p>Then push it to the device:</p>
<pre><code>adb push start_valgrind_app /data/local</code></pre>
<p>and make it executable:</p>
<pre><code>adb shell chmod 755 /data/local/start_valgrind_app</code></pre>
<p>and tell Android to use the script to launch your application:</p>
<pre><code>adb shell setprop wrap.org.libsdl.app &quot;logwrapper /data/local/start_valgrind_app&quot;</code></pre>
<p>If the setprop command says &quot;could not set property&quot;, it&#39;s likely
that your package name is too long and you should make it shorter by
changing AndroidManifest.xml and the path to your class file in
android-project/src</p>
<p>You can then launch your application normally and waaaaaaaiiittt for
it. You can monitor the startup process with the logcat command above,
and when it&#39;s done (or even while it&#39;s running) you can grab the
valgrind output file:</p>
<pre><code>adb pull /sdcard/valgrind.log</code></pre>
<p>When you&#39;re done instrumenting with valgrind, you can disable the
wrapper:</p>
<pre><code>adb shell setprop wrap.org.libsdl.app &quot;&quot;</code></pre>
<h1 id="graphics-debugging">Graphics debugging</h1>
<p>If you are developing on a compatible Tegra-based tablet, NVidia
provides Tegra Graphics Debugger at their website. Because SDL3
dynamically loads EGL and GLES libraries, you must follow their
instructions for installing the interposer library on a rooted device.
The non-rooted instructions are not compatible with applications that
use SDL3 for video.</p>
<p>The Tegra Graphics Debugger is available from NVidia here: <a href="https://developer.nvidia.com/tegra-graphics-debugger">https://developer.nvidia.com/tegra-graphics-debugger</a></p>
<h1 id="a-note-regarding-the-use-of-the-dirty-rectangles-rendering-technique">A
note regarding the use of the &quot;dirty rectangles&quot; rendering
technique</h1>
<p>If your app uses a variation of the &quot;dirty rectangles&quot; rendering
technique, where you only update a portion of the screen on each frame,
you may notice a variety of visual glitches on Android, that are not
present on other platforms. This is caused by SDL&#39;s use of EGL as the
support system to handle OpenGL ES/ES2 contexts, in particular the use
of the eglSwapBuffers function. As stated in the documentation for the
function &quot;The contents of ancillary buffers are always undefined after
calling eglSwapBuffers&quot;.</p>
<h1 id="ending-your-application">Ending your application</h1>
<p>Two legitimate ways:</p>
<ul>
<li><p>return from your main() function. Java side will automatically
terminate the Activity by calling Activity.finish().</p></li>
<li><p>Android OS can decide to terminate your application by calling
onDestroy() (see Activity life cycle). Your application will receive an
SDL_EVENT_QUIT you can handle to save things and quit.</p></li>
</ul>
<p>Don&#39;t call exit() as it stops the activity badly.</p>
<p>NB: &quot;Back button&quot; can be handled as a SDL_EVENT_KEY_DOWN/UP events,
with Keycode SDLK_AC_BACK, for any purpose.</p>
<h1 id="known-issues">Known issues</h1>
<ul>
<li>The number of buttons reported for each joystick is hardcoded to be
36, which is the current maximum number of buttons Android can
report.</li>
</ul>
<h1 id="building-the-sdl-tests">Building the SDL tests</h1>
<p>SDL&#39;s CMake build system can create APK&#39;s for the tests. It can build
all tests with a single command without a dependency on gradle or
Android Studio. The APK&#39;s are signed with a debug certificate. The only
caveat is that the APK&#39;s support a single architecture.</p>
<h3 id="requirements-1">Requirements</h3>
<ul>
<li>SDL source tree</li>
<li>CMake</li>
<li>ninja or make</li>
<li>Android Platform SDK</li>
<li>Android NDK</li>
<li>Android Build tools</li>
<li>Java JDK (version should be compatible with Android)</li>
<li>keytool (usually provided with the Java JDK), used for generating a
debug certificate</li>
<li>zip</li>
</ul>
<h3 id="cmake-configuration">CMake configuration</h3>
<p>When configuring the CMake project, you need to use the Android NDK
CMake toolchain, and pass the Android home path through
<code>SDL_ANDROID_HOME</code>.</p>
<pre><code>cmake .. -DCMAKE_TOOLCHAIN_FILE=&lt;path/to/android.toolchain.cmake&gt; -DANDROID_ABI=&lt;android-abi&gt; -DSDL_ANDROID_HOME=&lt;path-to-android-sdk-home&gt; -DANDROID_PLATFORM=23 -DSDL_TESTS=ON</code></pre>
<p>Remarks:</p>
<ul>
<li><code>android.toolchain.cmake</code> can usually be found at
<code>$ANDROID_HOME/ndk/x.y.z/build/cmake/android.toolchain.cmake</code></li>
<li><code>ANDROID_ABI</code> should be one of <code>arm64-v8a</code>,
<code>armeabi-v7a</code>, <code>x86</code> or <code>x86_64</code>.</li>
<li>When CMake is unable to find required paths, use
<code>cmake-gui</code> to override required <code>SDL_ANDROID_</code>
CMake cache variables.</li>
</ul>
<h3 id="building-the-apks">Building the APK&#39;s</h3>
<p>For the <code>testsprite</code> executable, the
<code>testsprite-apk</code> target will build the associated APK:</p>
<pre><code>cmake --build . --target testsprite-apk</code></pre>
<p>APK&#39;s of all tests can be built with the <code>sdl-test-apks</code>
target:</p>
<pre><code>cmake --build . --target sdl-test-apks</code></pre>
<h3 id="installationremoval-of-the-tests">Installation/removal of the
tests</h3>
<p><code>testsprite.apk</code> APK can be installed on your Android
machine using the <code>install-testsprite</code> target:</p>
<pre><code>cmake --build . --target install-testsprite</code></pre>
<p>APK&#39;s of all tests can be installed with the
<code>install-sdl-test-apks</code> target:</p>
<pre><code>cmake --build . --target install-sdl-test-apks</code></pre>
<p>All SDL tests can be uninstalled with the
<code>uninstall-sdl-test-apks</code> target:</p>
<pre><code>cmake --build . --target uninstall-sdl-test-apks</code></pre>
<h3 id="starting-the-tests">Starting the tests</h3>
<p>After installation, the tests can be started using the Android
Launcher GUI. Alternatively, they can also be started using CMake
targets.</p>
<p>This command will start the testsprite executable:</p>
<pre><code>cmake --build . --target start-testsprite</code></pre>
<p>There is also a convenience target which will build, install and
start a test:</p>
<pre><code>cmake --build . --target build-install-start-testsprite</code></pre>
<p>Not all tests provide a GUI. For those, you can use
<code>adb logcat</code> to read the output.</p>
</body>
</html>
